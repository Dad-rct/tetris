{"version":3,"file":"main.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/coord.ts","webpack:///./src/gameBoard.ts","webpack:///./src/index.ts","webpack:///./src/shape.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"../js/producer/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","export interface iCOORD {\n    x: number;\n    y: number;\n}\n\nexport class COORD implements iCOORD {\n    x;\n    y;\n    constructor(args: { x: number, y: number }) {\n        this.x = args.x;\n        this.y = args.y;\n    }\n    offset(other: iCOORD) {\n        return new COORD({ x: this.x + other.x, y: this.y + other.y });\n    }\n}","import { COORD } from \"./coord\";\nimport { Shape } from \"./shape\";\n\nconst squareSize = 40;\nconst gameBoardSquaresWidthCount = 10;\nconst gameBoardSquaresHeightCount = 20;\n\nconst canvasWidth = gameBoardSquaresWidthCount * squareSize;\nconst canvasHeight = gameBoardSquaresHeightCount * squareSize;\nexport class GameBoard {\n    private canvasBoard;\n    private canvasPieces;\n    private ctxBoard;\n    private ctxPieces;\n    constructor(args: { parentElement: HTMLElement | null }) {\n        if (!args.parentElement)\n            throw new Error(\"No parent element\");\n        this.canvasBoard = document.createElement(\"canvas\");\n        this.canvasPieces = document.createElement(\"canvas\");\n        args.parentElement.appendChild(this.canvasBoard);\n        args.parentElement.appendChild(this.canvasPieces);\n        this.canvasBoard.width = this.canvasPieces.width = canvasWidth;\n        this.canvasBoard.height = this.canvasPieces.height = canvasHeight;\n        this.canvasBoard.id = \"canvasBoard\";\n        this.canvasPieces.id = \"canvasPieces\";\n        this.canvasPieces.style.position = \"\";\n        const ctxBoard = this.canvasBoard.getContext(\"2d\");\n        const ctxPieces = this.canvasPieces.getContext(\"2d\");\n        if (!ctxBoard || !ctxPieces) throw new Error(\"Unable to create context\");\n        this.ctxBoard = ctxBoard;\n        this.ctxPieces = ctxPieces;\n        this.ctxBoard.strokeStyle = \"#AAA\";\n        this.ctxBoard.lineWidth = 0.5;\n    }\n    drawBoard() {\n\n        for (let x = 1; x < gameBoardSquaresWidthCount; x++) {\n            const lineX = x * squareSize - this.ctxBoard.lineWidth / 2;\n            const lineYStart = 0\n            const lineYEnd = canvasHeight;\n            this.ctxBoard.beginPath();\n            this.ctxBoard.moveTo(lineX, lineYStart);\n            this.ctxBoard.lineTo(lineX, lineYEnd);\n            this.ctxBoard.stroke();\n        }\n\n        for (let y = 1; y < gameBoardSquaresHeightCount; y++) {\n            const lineY = y * squareSize - this.ctxBoard.lineWidth / 2;\n            const lineXStart = 0\n            const lineXEnd = canvasWidth;\n            this.ctxBoard.beginPath();\n            this.ctxBoard.moveTo(lineXStart, lineY);\n            this.ctxBoard.lineTo(lineXEnd, lineY);\n            this.ctxBoard.stroke();\n        }\n    }\n    /**add the co-ordinates for a shape to the coordinates for it's pixels */\n    private getPixelsWithOffset(shape: Shape, at: COORD) {\n        const pixels = shape.getPixels();\n        return pixels.map(p => p.offset(at))\n    }\n    /**test if a shape can be drawn at the coordinates given */\n    canDrawShape(shape: Shape, at: COORD) {\n        const pixels = this.getPixelsWithOffset(shape, at);\n        for (const pixel of pixels) {\n            //test if shape can be drawn here\n            if (\n                pixel.x >= gameBoardSquaresWidthCount\n                || pixel.y >= gameBoardSquaresHeightCount\n                || pixel.x < 0 || pixel.y < 0\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //** draw or erase a shape from the canvas\n    private drawOrClearShape(shape: Shape, at: COORD, clear: boolean) {\n        const pixels = this.getPixelsWithOffset(shape, at);\n        this.ctxPieces.fillStyle = shape.color;\n        this.ctxPieces.strokeStyle = shape.color;\n        this.ctxPieces.beginPath();\n        const fn = clear\n            ? this.ctxPieces.clearRect.bind(this.ctxPieces)\n            : this.ctxPieces.fillRect.bind(this.ctxPieces);\n        for (const pixel of pixels) {\n            fn(\n                pixel.x * squareSize,\n                pixel.y * squareSize,\n                squareSize,\n                squareSize\n            );\n        }\n        this.ctxPieces.stroke();\n    }\n    drawShape(shape: Shape, at: COORD) {\n        return this.drawOrClearShape(shape, at, false);\n    }\n    clearShape(shape: Shape, at: COORD) {\n        return this.drawOrClearShape(shape, at, true);\n    }\n}\n","import { COORD } from \"./coord\";\nimport { GameBoard } from \"./gameBoard\"\nimport { AllShapeColours, AllShapes, Shape } from \"./shape\";\n\nlet currentShapeIndex = 0;\nlet currentColorIndex = 0;\nlet currentShape = new Shape({ shape: AllShapes[currentShapeIndex], color: AllShapeColours[currentColorIndex] });\nlet currentShapeCOORDS = new COORD({ x: 0, y: 0 });\n\n\ndocument.addEventListener(\"readystatechange\", async () => {\n    if (document.readyState === \"complete\") {\n        const board = new GameBoard({ parentElement: document.getElementById(\"boardContainer\") });\n        board.drawBoard();\n        board.drawShape(currentShape, currentShapeCOORDS);\n        document.addEventListener(\"keydown\", e => {\n            console.log(e.key)\n            switch (e.key) {\n                case \" \":\n                    //change of shape\n                    board.clearShape(currentShape, currentShapeCOORDS);\n                    currentShapeIndex++;\n                    currentShapeIndex = currentShapeIndex % AllShapes.length;\n                    currentShape = new Shape({ shape: AllShapes[currentShapeIndex], color: AllShapeColours[currentColorIndex] });\n                    board.drawShape(currentShape, currentShapeCOORDS);\n                    break;\n                case \"r\": {\n                    const oldShape = JSON.parse(JSON.stringify(currentShape.shape));\n                    board.clearShape(currentShape, currentShapeCOORDS);\n                    currentShape.rotate();\n                    if (!board.canDrawShape(currentShape, currentShapeCOORDS)) {\n                        currentShape.shape = oldShape;\n                    }\n                    board.drawShape(currentShape, currentShapeCOORDS)\n                    break;\n                }\n                case \"ArrowRight\":\n                case \"ArrowLeft\":\n                case \"ArrowUp\":\n                case \"ArrowDown\":\n                    const newCOORD = new COORD(currentShapeCOORDS);\n                    switch (e.key) {\n                        case \"ArrowRight\":\n                            newCOORD.x++;\n                            break;\n                        case \"ArrowLeft\":\n                            newCOORD.x--;\n                            break;\n                        case \"ArrowDown\":\n                            newCOORD.y++;\n                            break;\n                        case \"ArrowUp\":\n                            newCOORD.y--;\n                            break;\n                    }\n                    if (!board.canDrawShape(currentShape, newCOORD)) {\n                        return;\n                    }\n                    board.clearShape(currentShape, currentShapeCOORDS);\n                    //shape can be drawn at the required location\n                    currentShapeCOORDS.x = newCOORD.x;\n                    currentShapeCOORDS.y = newCOORD.y\n                    board.drawShape(currentShape, currentShapeCOORDS)\n                    break;\n                case \"c\":\n                    //change colour\n                    currentColorIndex++;\n                    currentColorIndex = currentColorIndex % AllShapeColours.length;\n                    currentShape.color = AllShapeColours[currentColorIndex];\n                    board.drawShape(currentShape, currentShapeCOORDS);\n                    break;\n            }\n        })\n\n\n    }\n});\n","import { COORD } from \"./coord\";\n\n\nexport type Tuple2<T> = [T, T];\nexport type Tuple3<T> = [T, T, T];\nexport type Tuple4<T> = [T, T, T, T];\n\nexport type ShapePixel = \" \" | \"X\"\n\nexport type Square4Shape = Tuple4<Tuple4<ShapePixel>>\nexport type Square3Shape = Tuple3<Tuple3<ShapePixel>>\nexport type Square2Shape = Tuple2<Tuple2<ShapePixel>>\n\n\n// 2 x 2 shapes\nexport const ShapeO: Square2Shape =\n    [\n        ['X', 'X'],\n        ['X', 'X'],\n    ];\n\n//3 x 3 shapes\nexport const ShapeS: Square3Shape =\n    [\n        [' ', ' ', ' '],\n        [' ', 'X', 'X'],\n        ['X', 'X', ' '],\n    ];\n\nexport const ShapeZ: Square3Shape =\n    [\n        [' ', ' ', ' '],\n        ['X', 'X', ' '],\n        [' ', 'X', 'X'],\n    ];\nexport const ShapeL: Square3Shape =\n    [\n        [' ', 'X', ' '],\n        [' ', 'X', ' '],\n        [' ', 'X', 'X'],\n    ];\n\nexport const ShapeJ: Square3Shape =\n    [\n        [' ', 'X', ' '],\n        [' ', 'X', ' '],\n        ['X', 'X', ' '],\n    ];\n\nexport const ShapeT: Square3Shape =\n    [\n        ['X', 'X', 'X'],\n        [' ', 'X', ' '],\n        [' ', ' ', ' '],\n    ];\n\n//4 x 4 shapes\nexport const ShapeI: Square4Shape =\n    [\n        [' ', ' ', 'X', ' '],\n        [' ', ' ', 'X', ' '],\n        [' ', ' ', 'X', ' '],\n        [' ', ' ', 'X', ' '],\n    ];\n\nexport const AllShapes = [\n    ShapeI,\n    ShapeJ,\n    ShapeL,\n    ShapeO,\n    ShapeS,\n    ShapeT,\n    ShapeZ\n]\nexport const AllShapeColours = [\n    \"#F00\",\n    \"#0F0\",\n    \"#00F\",\n    \"#0FF\",\n    \"#F0F\",\n    \"#FF0\",\n]\nexport class Shape {\n    shape: Square2Shape | Square3Shape | Square4Shape;\n    color;\n    constructor(args: {\n        shape: Square2Shape | Square3Shape | Square4Shape,\n        color: string\n    }) {\n        this.shape = args.shape;\n        this.color = args.color;\n    }\n    rotate() {\n        const out: typeof this.shape = JSON.parse(JSON.stringify(this.shape));\n        for (const [rowI, row] of this.shape.entries()) {\n            for (const [colI, col] of row.entries()) {\n                out[colI][row.length - rowI - 1] = col;\n            }\n        }\n        this.shape = out;\n    }\n    getPixels() {\n        return this.shape.map((row, y) => {\n            return row.map((val, x) => {\n                if (val === \"X\")\n                    return [new COORD({ x, y })]\n                return [];\n            }).flat();\n        }).flat();\n    }\n    log() {\n        console.log(\"------------------------------\")\n        for (const row of this.shape) {\n            console.log(row)\n        }\n        console.log(\"------------------------------\")\n    }\n}"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7EA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5FA;;;;;;;;;;;;;;;ACTA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;AC5EA;AAcA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;;;;;A","sourceRoot":""}